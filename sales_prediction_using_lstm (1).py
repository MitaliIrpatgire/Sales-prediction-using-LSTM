# -*- coding: utf-8 -*-
"""Sales prediction using LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B5-r8-yhu-Akti_9zhLLzI7FHHm3JZ5C
"""





import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator
from sklearn.metrics import mean_absolute_error

# Set seed for reproducibility
np.random.seed(42)

# Generate More Realistic Synthetic Sales Data with Trend and Seasonality
dates = pd.date_range(start='2022-01-01', periods=365, freq='D')
trend = np.linspace(100, 1000, 365)  # Linear trend from 100 to 1000
seasonality = 100 * np.sin(np.linspace(0, 3 * np.pi, 365))  # Seasonal component
sales = trend + seasonality + np.random.normal(0, 50, 365)  # Add some noise

data = pd.DataFrame({'Date': dates, 'Sales': sales})
data.set_index('Date', inplace=True)  # Fixed the typo here

# Adding additional features like day of week and month for better predictions
data['DayOfWeek'] = data.index.dayofweek
data['Month'] = data.index.month

# Normalize the features
scaler_features = MinMaxScaler()
data[['Sales', 'DayOfWeek', 'Month']] = scaler_features.fit_transform(data[['Sales', 'DayOfWeek', 'Month']])

# Prepare sequences for LSTM
n_input = 10  # Use past 10 days to predict the next day
generator = TimeseriesGenerator(data[['Sales', 'DayOfWeek', 'Month']].values,
                                data['Sales'].values,
                                length=n_input,
                                batch_size=1)

# Split the data
train_size = int(len(data) * 0.8)
train_data = data[:train_size]
test_data = data[train_size:]
generator_train = TimeseriesGenerator(train_data[['Sales', 'DayOfWeek', 'Month']].values,
                                      train_data['Sales'].values,
                                      length=n_input,
                                      batch_size=1)
generator_test = TimeseriesGenerator(test_data[['Sales', 'DayOfWeek', 'Month']].values,
                                     test_data['Sales'].values,
                                     length=n_input,
                                     batch_size=1)

# Define and Train the Improved LSTM Model
model = Sequential()
model.add(LSTM(64, activation='relu', input_shape=(n_input, 3), return_sequences=True))
model.add(LSTM(32, activation='relu', return_sequences=False))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model with more epochs
history = model.fit(generator_train, epochs=50, verbose=1)

# Plot training loss
plt.plot(history.history['loss'])
plt.title('Model Loss During Training')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.show()

# Make Predictions and Evaluate the Model
predictions = []
true_values = []

for i in range(len(test_data) - n_input):
    x, y = generator_test[i]
    y_pred = model.predict(x)
    predictions.append(y_pred)
    true_values.append(y)

# Convert to numpy arrays
predictions = np.array(predictions).reshape(-1, 1)
true_values = np.array(true_values).reshape(-1, 1)

# Inverse transform predictions
predictions = scaler_features.inverse_transform(np.hstack((predictions, np.zeros_like(predictions), np.zeros_like(predictions))))[:, 0]
true_values = scaler_features.inverse_transform(np.hstack((true_values, np.zeros_like(true_values), np.zeros_like(true_values))))[:, 0]

# Plot results
plt.figure(figsize=(12, 6))
plt.plot(test_data.index[n_input:], true_values, label='Actual Sales')
plt.plot(test_data.index[n_input:], predictions, label='Predicted Sales', color='red')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.title('Sales Prediction')
plt.legend()
plt.show()

# Calculate Mean Absolute Error
mae = mean_absolute_error(true_values, predictions)
print(f'Mean Absolute Error: {mae:.2f}')

# Calculate percentage MAE
average_sales = np.mean(scaler_features.inverse_transform(data[['Sales', 'DayOfWeek', 'Month']].values)[:, 0])
mae_percentage = (mae / average_sales) * 100
print(f"MAE as a percentage of average sales: {mae_percentage:.2f}%")



